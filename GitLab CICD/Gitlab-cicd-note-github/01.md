# GitLab CI/CD 

* [基本寫法](#基本寫法)

  * [最簡單的腳本](#最簡單的腳本)
  * [多個 Job](#多個-job)
  * [before_script & after_script](#before_script--after_script)
  * [變數 -- variables](#變數----variables)
  * [預設提供的環境變數 -- predefined variables](#預設提供的環境變數----predefined-variables)
  * [更改執行環境所用的 Docker image](#更改執行環境所用的-docker-image)
  * [使用 shell script](#使用-shell-script)


* [使用錨點(Anchor)](#使用錨點anchor)
* [繼承 --- extends](#繼承----extends)

* [相依關係 & 條件處理](#相依關係--條件處理)

  * [多階段處理 -- stages](#多階段處理----stages)
  * [設定相依關係 -- needs](#設定相依關係----needs)
  * [若當前 Job 失敗，後續 stage 仍然執行 -- allow_failure](#若當前-job-失敗後續-stage-仍然執行----allow_failure)
  * [特定條件下才執行 Job -- when](#特定條件下才執行-job----when)
  * [更高級的條件控制 -- rules](#更高級的條件控制----rules)
  * [甚麼情況下才創立 Pipeline -- workflow](#甚麼情況下才創立-pipeline----workflow)
  * [指定分支執行特定 Job -- only](#指定分支執行特定-job----only)
  * [指定那些分支不執行特定 Job -- except](#指定那些分支不執行特定-job----except)

* [常用的分支條件](#常用的分支條件)

* [runner vs executor](#runner-vs-executor)
  * [tags --- 指定帶有特定 tag 的 Runner 執行 Job](#tags-----指定帶有特定-tag-的-runner-執行-job)

## 基本寫法

### 最簡單的腳本

```yaml
helloworld:  # Job 的名稱，可以自訂
    script:  # 固定寫法
        - echo "Hello, World!"
```

### 多個 Job

```yaml
bad-job:
    script:
        - fffffff  # 故意寫錯


helloworld:  # Job 的名稱，可以自訂
    script:  # 固定寫法
        - echo "Hello, World!"

goodbye:  # Job 的名稱，可以自訂
    script:  # 固定寫法
        - echo "Goodbye!"
```
> 由於 bad-job 有錯誤，所以會失敗，但因為和後續的 Job 無關，所以後續的 Job 會繼續執行。


### before_script & after_script

```yaml
hello:  
    before_script:  # Job 執行前會先執行的指令
        - echo "Before script"
    script:  
        - echo "Hello, World!"
    after_script:  # Job 執行後會執行的指令
        - echo "After script"
```

### 變數 -- variables

```yaml
variables:  # 全域變數
    NAME: "GitLab"

hello-to-you:
  variables:  # 只有這個 Job 才抓的到此變數值
    NAME: "Michael"
  script:
    - echo "Hello, $NAME"   # 會印出 Hello, Michael

hello-to-gitlab:
    script:
        - echo "Hello, $NAME"  # 會印出 Hello, GitLab
```

### 預設提供的環境變數 -- predefined variables

> 官網：https://docs.gitlab.com/ee/ci/variables/predefined_variables.html#predefined-variables

### 更改執行環境所用的 Docker image 

> 也類似全域變數的概念，可以在全域設定，也可以在 Job 裡設定。

```yaml
image: alpine:latest

helloworld: # 使用 alpine
    script:
        - echo "Hello, World!"

print-golang-version:
    image: golang:1.24rc1-alpine3.21  # 使用 golang:1.24rc1-alpine3.21
    script:
        - go version  # 使用預設的 golang image
```

## 使用錨點(Anchor)

> [參考文章](https://ithelp.ithome.com.tw/articles/10246051)

將一個 Job 定義成錨點，錨點本身不會執行，除非被其他 Job 引用。

* 隱藏 Job (Job 名稱前加上 .)： 
```yaml
.hello:
    script:
        - echo "Hello, World!"
```

* 設定 Job 為錨點( .job-name: &job-name )： 
```yaml
.hello: &hello
    script:
        - echo "Hello, World!"
```

* 引用錨點的 script(*anchor)： 
```yaml
.hello: &hello
    script:
        - echo "Hello, World!"

hello-to-you:
    *hello
```

* 引用「整段」錨點，含變數等設定(<<: *anchor)：
```yaml
.hello: &hello
    variables:
        AGE: 18
        NAME: "GitLab"

hello-to-you:
    <<: *hello
    script:
        - echo "Hello, $NAME, you are $AGE years old."
        # result: Hello, GitLab, you are 18 years old.
```

> 注意，錨點後面重複的設定會**完全**覆蓋掉錨點的設定。例如 hello-to-you 的 script 會覆蓋掉 hello 的 script，但由於是整段引用，因此變數 AGE 一樣可以抓到值。但下面的範例中，由於 hello-to-you 重新定義了 variables，所以會覆蓋掉錨點 variables 的「全部」設定，因此 $NAME 會變成 hahahahah，而 $AGE 則會變成空值！！

```yaml
.hello: &hello
    variables:
        AGE: 18
        NAME: "GitLab"

hello-to-you:
    <<: *hello
    variables:
        NAME: "hahahahah"
    script:
        - echo "Hello, $NAME, you are $AGE years old."
        # result: Hello, hahahahah, you are  years old.
```

## 繼承 --- extends

> [anchor vs extends](https://stackoverflow.com/questions/75005137/what-is-difference-between-extends-and-anchor-tag-anchor-in-yaml-gitlab)

extends 的用法和 anchor 很像，但 extends 不會因為後面的設定不完全而導致空值，而是會保留原本的設定。

```yaml

.hello: &hello
    variables:
        AGE: 18
        NAME: "GitLab"

hello-to-you:
    extends:
        - .hello
    variables:
        NAME: "hahahahah"
    script:
        - echo "Hello, $NAME, you are $AGE years old."
        # result: Hello, hahahahah, you are 18 years old.
```

另外，extends 也可以繼承其他 ci yml 的 job 設定：

```yaml
include:
 - 'https://example.com/some-file.yaml'

# this will work
my_job:
  extends: .some-anchor-from-the-included-file

# this will fail
my_other_job:
  <<: *some-anchor-from-the-included-file
```


### 使用 shell script

* test.sh：

```bash
#!/bin/bash

echo "starting shell script"
echo "doing something"
echo "end of shell script"
```

* .gitlab-ci.yml：

```yaml
run-script:
    script:
        - echo "try running script"
        - chmod +x ./test.sh  # 設定 script.sh 可執行
        - ./test.sh  # 執行 script.sh
```

### Pipeline 輸出的檔案保存 --- artifacts

在腳本中所產生的檔案，可以透過 artifacts 保存下來，以便後續使用。

```yaml
time-output:
    image: alpine:latest
    script:
        - date > test.log  # 將日期寫入 test.log 檔案
    artifacts:
        paths:
            - ./test.log  # 保存在 git 根目錄下
```


## 相依關係 & 條件處理

### 多階段處理 -- stages

```yaml
# 只要前面有 stage 失敗，後面的 stage 就不會執行
stages:
  - check
  - testing
  - build
  - deploy

check-syntax:
  stage: check # 表示這個 Job 屬於 check stage
  script:
    - echo "Checking syntax"

unit-test:
    stage: testing 
    script:
        - echo "Running unit tests"

failed-test:
    stage: testing 
    script:
        - ffffff  # 故意寫錯

build-image:
    stage: build
    script:
        - echo "Building image"

deploy:
    stage: deploy
    script:
        - echo "Deploying"
```
![alt text](image.png)

### 設定相依關係 -- needs

> 可以用來處理同 stage 的 Job 之間的相依關係

```yaml
stages:
  - check
  - testing
  - build
  - deploy

check-syntax:
  stage: check # 表示這個 Job 屬於 check stage
  script:
    - echo "Checking syntax"

unit-test:
    stage: testing 
    needs:
        - failed-test  # 表示這個 Job 需要 failed-test 完成後才能執行
    script:
        - echo "Running unit tests"

failed-test:
    stage: testing 
    script:
        - ffffff  # 故意寫錯

build-image:
    stage: build
    script:
        - echo "Building image"

deploy:
    stage: deploy
    script:
        - echo "Deploying"
```
![alt text](image-1.png)


### 若當前 Job 失敗，後續 stage 仍然執行 -- allow_failure

```yaml
stages:
  - check
  - build

check-syntax:
    stage: check
    script:
        - ffff
    allow_failure: true

build-image:
    stage: build
    script:
        - echo "Building image"
```
![alt text](image-4.png)


### 特定條件下才執行 Job -- when

格式：
```yaml
when: <condition>
```

condition：

* on_success：前面的 stage 成功後執行

* on_failure：前面的 stage 失敗後執行

* always：不管前面的 stage 成功或失敗都執行

* nerer：永遠不執行 (只又在 rules 才能使用)

* manual：手動觸發(預設會將此 Job 設定為 allow_failure: true)

* delayed：延遲執行 (搭配 start_in 使用)

```yaml
stages:
  - check
  - testing
  - fix
  - build

check-syntax:
    stage: check
    when: manual  # 手動觸發 (到 Gitlab CI/CD 頁面手動觸發)
    allow_failure: false  # 如果使用預設的 true，無論手動觸發了沒，下個 stage 都會執行 
    script:
        - echo "Checking syntax"

unit-test:
    stage: testing 
    script:
        - ffffff # 故意寫錯

fix-error:
    stage: fix
    when: on_failure  # 只有前一個 stage 失敗時才執行
    script:
        - echo "Fixing error"

build-image:
    stage: build
    when: delayed  # 延遲執行
    start_in: 5 seconds # 延遲 5 秒後執行
    script:
        - echo "Building image"
```

### 更高級的條件控制 -- rules

> [官方文件](https://docs.gitlab.com/ee/ci/yaml/index.html#rules)

rules 可以定義多個條件，只有當條件都被滿足時才會執行 Job。
  * rules + if：條件判斷
  * rules + changes：檔案變更
  * rules + exists：檔案存在
  * rules + when：執行情況

**範例一**
> 當 CI_COMMIT_BRANCH 為 main & Dockerfile 存在時，則手動觸發 check-syntax Job。
> 當 NAME 為 Michael 時，則執行 check-syntax Job。
> 上述情況都不符合時，則永遠不執行 check-syntax Job。

```yaml
check-syntax:
    rules:
        - if: $CI_COMMIT_BRANCH == "main"
          exists:
            - Dockerfile 
          when: manual
        - if: $NAME == "Michael"
        - when: never
    script:
        - echo "Checking syntax..."
```

### 甚麼情況下才創立 Pipeline -- workflow

使用 workflow + rules，我們可以設定在什麼情況下才創立 Pipeline。

```yaml
workflow:
    rules:
        - if: $CI_PIPELINE_SOURCE == "merge_request_event"  # 只有當 merge request 時才創立 Pipeline
          when: always
        - when: never  # 其他情況都不創立 Pipeline

testing-job:
    script:
        - echo "Running tests..."
```



### 指定分支執行特定 Job -- only

```yaml
stages:
  - check
  - testing
  - build
  - deploy

check-syntax:
  stage: check # 表示這個 Job 屬於 check stage
  script:
    - echo "Checking syntax"

unit-test:
    stage: testing 
    script:
        - echo "Running unit tests"


build-image:
    stage: build
    only:
        - main # 只有 main 分支會執行這個 Job
    script:
        - echo "Building image"

deploy:
    stage: deploy
    only:
        - main # 只有 main 分支會執行這個 Job
    script:
        - echo "Deploying"
```

* 用 dev 分支 push .gitlab-ci.yml：
![alt text](image-2.png)

* 用 main 分支 push .gitlab-ci.yml：
![alt text](image-3.png)

### 指定那些分支不執行特定 Job -- except

寫法和 only 一樣，就把 only 改成 except 就可以了。

## 常用的分支條件


### runner vs executor

三個角色：

* GitLab：使用者將任務上傳到 GitLab (發包公司)

* Runner：GitLab 把任務清單交給 Runner (經紀人)

* Executor：Runner 把任務交給 Executor 執行 (工人)


### tags --- 指定帶有特定 tag 的 Runner 執行 Job

Runner 在註冊時會填寫多個 tag，使用 tags 指定特定的 Runner 執行 Job：

```yaml
hello:
    tags:
        - docker
    script:
        - echo "Hello, World!"
```